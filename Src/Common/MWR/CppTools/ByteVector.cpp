#include "StdAfx.h"
#include "ByteVector.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector::~ByteVector()
{
	// Increase OpSec by clearing memory when ByteVector is not needed anymore.
	SecureZeroMemory(data(), size());
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector::ByteVector(ByteVector const& other)
	: Super(static_cast<Super const&>(other))
{

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector::ByteVector(ByteVector&& other)
	: Super(static_cast<Super&&>(other))
{

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector::ByteVector(std::vector<uint8_t> other)
	: Super(std::move(other))
{

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector& MWR::ByteVector::operator=(ByteVector const& other)
{
	auto tmp = Super{ static_cast<Super const&>(other) };
	std::swap(static_cast<Super&>(*this), tmp);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector& MWR::ByteVector::operator=(ByteVector&& other)
{
	std::swap(static_cast<Super&>(*this), static_cast<Super&>(other));
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool MWR::operator==(ByteVector const& lhs, ByteVector const& rhs)
{
	if (lhs.size() != rhs.size())
		return false;

	for (size_t i = 0; i < lhs.size(); ++i)
		if (lhs[i] != rhs[i])
			return false;

	return true;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool MWR::operator!=(ByteVector const& lhs, ByteVector const& rhs)
{
	return !(lhs == rhs);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector MWR::Literals::operator "" _b(const char* data, size_t size)
{
	MWR::ByteVector ret;
	ret.resize(size);
	std::memcpy(ret.data(), data, size);
	return ret;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MWR::ByteVector MWR::Literals::operator "" _b(const wchar_t* data, size_t size)
{
	MWR::ByteVector ret;
	ret.resize(size * sizeof(wchar_t));
	std::memcpy(ret.data(), data, size * sizeof(wchar_t));
	return ret;
}
